<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" />
    <title>AR - Marcador Customizado</title>

    <!-- ✅ Versões COMPATÍVEIS -->
    <script src="https://aframe.io/releases/1.2.0/aframe.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/AR-js-org/AR.js/aframe/build/aframe-ar.js"></script>

    <style>
      * { margin: 0; padding: 0; box-sizing: border-box; }
      html, body { width: 100%; height: 100%; font-family: Arial, sans-serif; }
      body { background: #000; color: #0f0; overflow: hidden; }
      a-scene { width: 100%; height: 100%; }

      #status {
        position: fixed;
        top: 15px;
        left: 15px;
        background: rgba(0, 0, 0, 0.8);
        color: #0f0;
        border: 2px solid #0f0;
        padding: 20px;
        font-family: monospace;
        font-size: 14px;
        z-index: 1000;
        line-height: 1.6;
        min-width: 280px;
      }
      .ok { color: #0f0; font-weight: bold; }
      .erro { color: #f00; font-weight: bold; }
      .warn { color: #ff0; }

      #detectado {
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: rgba(0, 200, 0, 0.9);
        color: #fff;
        padding: 40px 80px;
        font-size: 36px;
        font-weight: bold;
        border: 4px solid #0f0;
        border-radius: 20px;
        z-index: 999;
        display: none;
        text-align: center;
      }
      #detectado.ativo {
        display: block;
        animation: pulse 0.5s;
      }
      @keyframes pulse {
        0% { transform: translate(-50%, -50%) scale(1); }
        50% { transform: translate(-50%, -50%) scale(1.1); }
        100% { transform: translate(-50%, -50%) scale(1); }
      }

      #instrucoes {
        position: fixed;
        bottom: 20px;
        left: 50%;
        transform: translateX(-50%);
        background: rgba(0, 0, 0, 0.9);
        color: #0ff;
        border: 2px solid #0ff;
        padding: 20px;
        text-align: center;
        font-size: 14px;
        max-width: 90%;
        z-index: 998;
      }
      /* botão discreto para reproduzir fala se autoplay for bloqueado */
      #btn-play-fala {
        position: fixed;
        right: 18px;
        bottom: 18px;
        z-index: 1001;
        background: #0a84ff;
        color: #fff;
        border: none;
        padding: 10px 14px;
        border-radius: 10px;
        font-weight: bold;
        box-shadow: 0 4px 10px rgba(0,0,0,0.4);
        cursor: pointer;
        display: none; /* mostrado apenas se necessário */
      }
      #btn-play-fala:active { transform: translateY(1px); }

      /* Menu de 3 pontos (uploads + transform + motion) */
      #menu-btn {
        position: fixed;
        right: 18px;
        top: 18px;
        z-index: 1003;
        width: 36px;
        height: 36px;
        border-radius: 10px;
        background: rgba(0,0,0,0.85);
        border: 1px solid #0ff;
        color: #0ff;
        font-weight: bold;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }
      #menu-panel {
        position: fixed;
        right: 18px;
        top: 60px;
        z-index: 1002;
        background: rgba(0,0,0,0.92);
        border: 1px solid #0ff;
        border-radius: 10px;
        padding: 10px 12px;
        color: #0ff;
        font-size: 12px;
        min-width: 260px;
        display: none;
      }
      #menu-panel h4 { margin: 6px 0; }
      #menu-panel label { display: block; margin: 6px 0 2px; }
      #menu-panel input[type="file"],
      #menu-panel input[type="range"],
      #menu-panel input[type="number"],
      #menu-panel input[type="text"] { width: 100%; }
      #menu-panel .row { display: grid; grid-template-columns: 1fr 1fr; gap: 8px; }
      #menu-panel .actions { display: flex; gap: 8px; margin-top: 8px; }
      #menu-panel button { background: #0a84ff; color: #fff; border: none; padding: 6px 8px; border-radius: 8px; cursor: pointer; }
    </style>
  </head>

  <body>
    <div id="status">
      <strong>STATUS AR</strong><br>
      Camara: <span id="cam" class="warn">⟳</span><br>
      A-Frame: <span id="af" class="warn">⟳</span><br>
      AR.js: <span id="ar" class="warn">⟳</span><br>
      Marcador: <span id="marker" class="erro">⟳ Procurando</span><br><br>
      Áudio: <span id="audioState" class="warn">Parado</span><br>
      <small id="msg">Inicializando...</small>
    </div>

    <div id="detectado">✓ MARCADOR DETECTADO!</div>

    <div id="instrucoes">
      <strong>Aponte a câmera para o marcador</strong><br>
      <a href="pattern-marker.patt" download>Baixar marcador</a>
    </div>

    <!-- Botão de menu (3 pontos) -->
    <div id="menu-btn" title="Opções">⋮</div>
    <!-- Painel de menu: uploads + transform + motion -->
    <div id="menu-panel" aria-label="Menu de opções">
      <h4>Uploads</h4>
      <label for="glbInput">Modelo (.glb)</label>
      <input id="glbInput" type="file" accept=".glb">
      <label for="audioInput">Áudio (opcional)</label>
      <input id="audioInput" type="file" accept="audio/*">
      <small>Use "Ouvir fala" para iniciar o áudio.</small>

      <h4>Transformar Modelo</h4>
      <label>Escala</label>
      <input id="scaleSlider" type="range" min="0.1" max="2.0" step="0.01" value="0.4">
      <div class="row">
        <div>
          <label>Posição X</label>
          <input id="posX" type="number" step="0.01" value="0">
        </div>
        <div>
          <label>Posição Y</label>
          <input id="posY" type="number" step="0.01" value="0">
        </div>
      </div>
      <div class="row">
        <div>
          <label>Posição Z</label>
          <input id="posZ" type="number" step="0.01" value="0">
        </div>
        <div>
          <label>Rotação Y</label>
          <input id="rotY" type="range" min="0" max="360" step="1" value="0">
        </div>
      </div>

      <h4>Motion</h4>
      <div class="actions">
        <button id="btn-idle" type="button">Idle</button>
        <button id="btn-wave" type="button">Acenar</button>
        <button id="btn-stop-motion" type="button">Parar</button>
      </div>

      <h4>Mapeamento</h4>
      <label>Clip Idle</label>
      <input id="mapClipIdle" type="text" placeholder="Idle">
      <label>Clip Wave</label>
      <input id="mapClipWave" type="text" placeholder="Wave">
      <label>Clip Talk</label>
      <input id="mapClipTalk" type="text" placeholder="Talk">
      <div class="row">
        <div>
          <label>Bone Jaw</label>
          <input id="mapBoneJaw" type="text" placeholder="Jaw">
        </div>
        <div>
          <label>Bone RightHand</label>
          <input id="mapBoneHandR" type="text" placeholder="RightHand">
        </div>
      </div>
      <label>Morph MouthOpen</label>
      <input id="mapMorphMouthOpen" type="text" placeholder="MouthOpen">
      <div class="actions">
        <button id="btn-apply-mapping" type="button">Aplicar Mapeamento</button>
        <label style="display:flex;align-items:center;gap:6px;">
          <input id="lipSyncEnabled" type="checkbox"> Lip-sync
        </label>
      </div>
    </div>

    <!-- Botão de fallback para iniciar a fala caso o navegador bloqueie autoplay -->
    <button id="btn-play-fala" aria-label="Ouvir fala">Ouvir fala</button>

    <!-- ✅ Cena AR configurada corretamente ✅ -->
    <a-scene
      embedded
      vr-mode-ui="enabled: false"
      arjs="trackingMethod: best; sourceType: webcam; debugUIEnabled: false;"
      renderer="logarithmicDepthBuffer: true;"
    >
      <a-assets>
        <a-asset-item id="model" src="model1.glb"></a-asset-item>
      </a-assets>

      <!-- ✅ Marcador com eventos funcionando -->
      <a-marker
        type="pattern"
        url="pattern-marker.patt"
        emitevents="true"
        id="meu-marker"
      >
        <!--
          `id="modelo-personagem"` -> facilita selecionar o modelo via JS
          `rotating-when-visible` -> componente custom que gira suavemente quando ativo
          `character-speech` -> componente custom para tocar áudio e preparar sincronização labial
        -->
        <a-gltf-model
          id="modelo-personagem"
          src="#model"
          position="0 0 0"
          scale="0.4 0.4 0.4"
          rotation="0 0 0"
          rotating-when-visible="speed: 15"
          character-speech="audioSelector: #fala1"
          character-motion
        ></a-gltf-model>
      </a-marker>

      <a-entity camera></a-entity>
    </a-scene>

      <!-- Áudio da personagem (pré-carregado).
        Coloque o arquivo `audio1.m4a` na mesma pasta do projeto. -->
      <audio id="fala1" src="audio1.m4a" preload="auto"></audio>

    <script>
      console.clear();
      console.log("=== AR INICIADO ===");

      document.getElementById("cam").textContent = "✓";
      document.getElementById("cam").className = "ok";

      document.addEventListener('DOMContentLoaded', () => {
        document.getElementById("af").textContent = "✓";
        document.getElementById("af").className = "ok";
        document.getElementById("ar").textContent = "✓";
        document.getElementById("ar").className = "ok";
      });

      // ✅ Eventos oficiais de AR.js
      const marker = document.getElementById("meu-marker");

      // Registramos dois componentes customizados abaixo:
      // 1) rotating-when-visible: roda o modelo no eixo Y enquanto ativo (deg/s)
      // 2) character-speech: toca um áudio e expõe método para sincronizar boca no futuro

      /* Componente: rotating-when-visible
         - data.speed: graus por segundo (default 15)
         - expõe métodos `start()` e `stop()` para controlar rotação externamente
         - usa tick() para atualização suave baseada em timeDelta (compatível A-Frame 1.2.0)
      */
      AFRAME.registerComponent('rotating-when-visible', {
        schema: { speed: { type: 'number', default: 15 } },
        init: function () {
          this.isRotating = false;
          // start/stop expostos para chamadas externas (ex.: markerFound/markerLost)
          this.start = () => { this.isRotating = true; };
          this.stop = () => { this.isRotating = false; };
        },
        tick: function (time, timeDelta) {
          // timeDelta em ms; converte para segundos
          if (!this.isRotating) return;
          const rot = this.el.getAttribute('rotation') || { x: 0, y: 0, z: 0 };
          // incrementa Y de forma suave: speed (deg/s) * dt
          rot.y = (rot.y + this.data.speed * (timeDelta / 1000)) % 360;
          this.el.setAttribute('rotation', rot);
        },
        remove: function () { this.isRotating = false; }
      });

      /* Componente: character-speech
         - data.audioSelector: seletor do elemento <audio> (default '#fala1')
         - fornece método `playSpeech()` para iniciar a fala
         - fornece método `stopSpeech()` para interromper
         - expõe `syncMouth()` placeholder para futura sincronização labial
      */
      AFRAME.registerComponent('character-speech', {
        schema: { audioSelector: { type: 'selector', default: '#fala1' } },
        init: function () {
          // A-Frame com schema selector já retorna o elemento se existir
          this.audioEl = this.data.audioSelector || document.querySelector('#fala1');
          this.isPlaying = false;
          // WebAudio para lip-sync básico
          this.audioCtx = null;
          this.mediaSrc = null;
          this.analyser = null;
          this._lipSyncRAF = null;

          // Handler que será chamado em cada update do áudio para futura sincronização
          this._onTimeUpdate = (ev) => {
            // Atualmente chamamos syncMouth como placeholder
            // TODO: implementar animação labial aqui (usar ev.currentTime para sincronizar)
            this.syncMouth(ev);
          };

          if (this.audioEl) {
            this.audioEl.addEventListener('timeupdate', this._onTimeUpdate);
          } else {
            console.warn('[character-speech] áudio não encontrado para selector', this.data.audioSelector);
          }

          // métodos públicos
          this.playSpeech = () => {
            if (!this.audioEl) { console.warn('[character-speech] áudio ausente'); return; }
            try {
              // Reinicia e tenta tocar. Note: navegadores podem bloquear autoplay sem interação do usuário.
              this.audioEl.currentTime = 0;
              const p = this.audioEl.play();
              if (p && p.then) {
                p.then(() => {
                  this.isPlaying = true;
                  // Se a reprodução começou com sucesso, garante que o botão de fallback fique oculto
                  const btn = document.getElementById('btn-play-fala');
                  if (btn) btn.style.display = 'none';
                  const audioState = document.getElementById('audioState');
                  if (audioState) { audioState.textContent = 'Reproduzindo'; audioState.className = 'ok'; }
                  // Inicia lip-sync se habilitado
                  this._startLipSync();
                }).catch(err => {
                  console.warn('play() falhou:', err);
                  // Mostra um botão para que o usuário permita reprodução manualmente
                  const btn = document.getElementById('btn-play-fala');
                  if (btn) btn.style.display = 'block';
                  const audioState = document.getElementById('audioState');
                  if (audioState) { audioState.textContent = 'Bloqueado'; audioState.className = 'warn'; }
                });
              } else {
                this.isPlaying = true;
              }
            } catch (e) {
              console.warn('[character-speech] erro ao tocar áudio', e);
              const btn = document.getElementById('btn-play-fala');
              if (btn) btn.style.display = 'block';
              const audioState = document.getElementById('audioState');
              if (audioState) { audioState.textContent = 'Erro'; audioState.className = 'erro'; }
            }
          };

          this.stopSpeech = () => {
            if (!this.audioEl) return;
            this.audioEl.pause();
            this.audioEl.currentTime = 0;
            this.isPlaying = false;
            const audioState = document.getElementById('audioState');
            if (audioState) { audioState.textContent = 'Parado'; audioState.className = 'warn'; }
            this._stopLipSync();
          };

          // Placeholder público para futuras implementações de sincronização labial
          this.syncMouth = (audioEventOrTime) => {
            // TODO: usar audioEventOrTime.currentTime ou valor numérico para animar a boca do personagem
            // Exemplo futuro: extrair volume ou usar WebAudio API para visemes.
          };

          // Lip-sync básico com WebAudio (RMS -> MouthOpen)
          this._startLipSync = () => {
            const lipCheck = document.getElementById('lipSyncEnabled');
            if (!lipCheck || !lipCheck.checked) return;
            if (!this.audioEl) return;
            try {
              if (!this.audioCtx) this.audioCtx = new (window.AudioContext || window.webkitAudioContext)();
              if (this.audioCtx.state === 'suspended') {
                // tentar retomar — navegadores exigem gesto do usuário
                this.audioCtx.resume().catch(()=>{});
              }
              if (!this.mediaSrc) this.mediaSrc = this.audioCtx.createMediaElementSource(this.audioEl);
              if (!this.analyser) {
                this.analyser = this.audioCtx.createAnalyser();
                this.analyser.fftSize = 512;
                this.analyser.smoothingTimeConstant = 0.7;
              }
              // conectar apenas ao analyser (não ao destination para evitar duplicidade de saída)
              this.mediaSrc.connect(this.analyser);
              const buf = new Uint8Array(this.analyser.frequencyBinCount);
              const motion = this.el.components['character-motion'];
              const loop = () => {
                this._lipSyncRAF = requestAnimationFrame(loop);
                if (!this.analyser) return;
                this.analyser.getByteTimeDomainData(buf);
                // Byte time-domain: centro ~128. calcula RMS normalizado
                let sum = 0;
                for (let i = 0; i < buf.length; i++) {
                  const v = (buf[i] - 128) / 128; // -1..1
                  sum += v * v;
                }
                const rms = Math.sqrt(sum / buf.length); // 0..1
                // Mapeia para 0..1 com leve ganho e clamp
                const mouth = Math.min(1, Math.max(0, rms * 1.8));
                if (motion && motion.setMorph) motion.setMorph('mouthOpen', mouth);
              };
              loop();
            } catch (e) {
              console.warn('Lip-sync WebAudio falhou:', e);
            }
          };

          this._stopLipSync = () => {
            if (this._lipSyncRAF) cancelAnimationFrame(this._lipSyncRAF);
            this._lipSyncRAF = null;
            const motion = this.el.components['character-motion'];
            if (motion && motion.setMorph) motion.setMorph('mouthOpen', 0);
          };
        },
        remove: function () {
          if (this.audioEl) this.audioEl.removeEventListener('timeupdate', this._onTimeUpdate);
        }
      });

      /* Componente: character-motion
         - Mixer de animações de clipes (GLB) + adapter para bones/morphs
         - API mínima: playMotion(nome, opts), stopMotion(nome), stopAll(), setMorph(chave, valor)
         - Config default (adaptável por nomes no GLB): clips: Idle/Wave/Talk; morphs: MouthOpen; bones: Jaw/RightHand
      */
      AFRAME.registerComponent('character-motion', {
        schema: { config: { type: 'string', default: '' } },
        init: function () {
          this.mixer = null;
          this.actions = {};
          this.animations = [];
          this.model = null;
          this.boneMap = {};
          this.morphTargets = [];

          // Configuração mínima padrão (pode ser ajustada depois via setConfig)
          this.config = {
            clips: { idle: 'Idle', wave: 'Wave', talk: 'Talk' },
            morphs: { mouthOpen: 'MouthOpen' },
            bones: { jaw: 'Jaw', handR: 'RightHand' }
          };

          this.setConfig = (cfg) => {
            if (!cfg) return;
            this.config = Object.assign({}, this.config, cfg);
          };

          this._buildMaps = () => {
            const mesh = this.model;
            if (!mesh) return;
            // Bones
            this.boneMap = {};
            Object.keys(this.config.bones).forEach(k => {
              const name = this.config.bones[k];
              const node = mesh.getObjectByName(name);
              if (node) this.boneMap[k] = node;
            });
            // Morph targets
            this.morphTargets = [];
            mesh.traverse(obj => {
              if (obj.morphTargetDictionary && obj.morphTargetInfluences) {
                this.morphTargets.push(obj);
              }
            });
          };

          this.onModelLoaded = () => {
            const mesh = this.el.getObject3D('mesh');
            if (!mesh) return;
            this.model = mesh;
            // Animações embutidas
            if (mesh.animations && mesh.animations.length) {
              this.animations = mesh.animations;
              this.mixer = new THREE.AnimationMixer(mesh);
            }
            this._buildMaps();
          };
          this.el.addEventListener('model-loaded', this.onModelLoaded);

          this._getClipByName = (clipName) => {
            if (!clipName || !this.animations) return null;
            return this.animations.find(c => c && c.name === clipName) || null;
          };

          this.playMotion = (name, opts = {}) => {
            const cfg = this.config.clips || {};
            const clipName = cfg[name];
            const clip = this._getClipByName(clipName);
            if (clip && this.mixer) {
              let action = this.actions[name];
              if (!action) {
                action = this.mixer.clipAction(clip);
                this.actions[name] = action;
              }
              const fade = opts.fade != null ? opts.fade : 0.2;
              const loop = opts.loop != null ? opts.loop : (name === 'idle');
              if (!loop) { action.setLoop(THREE.LoopOnce, 1); action.clampWhenFinished = true; }
              action.reset();
              // Crossfade de outras ações ativas
              Object.keys(this.actions).forEach(k => {
                if (k !== name) {
                  const other = this.actions[k];
                  if (other && other.isRunning()) other.fadeOut(fade);
                }
              });
              action.fadeIn(fade).play();
              return true;
            }
            // Fallback: se não houver clip, pode acionar adapter (ex.: wave -> rotacionar mão)
            if (name === 'wave' && this.boneMap.handR) {
              // Pequeno aceno procedural: rotaciona mão em Y por alguns ticks (simplificado)
              // Nota: para algo mais natural, use uma curva e um temporizador dedicado
              const hand = this.boneMap.handR;
              hand.rotation.y += THREE.MathUtils.degToRad(15);
              return true;
            }
            return false;
          };

          this.stopMotion = (name) => {
            const action = this.actions[name];
            if (action) { action.stop(); }
          };

          this.stopAll = () => {
            Object.keys(this.actions).forEach(k => { const a = this.actions[k]; if (a) a.stop(); });
          };

          this.setMorph = (key, value) => {
            // Procura o nome real do morph
            const real = (this.config.morphs || {})[key];
            if (!real) return;
            this.morphTargets.forEach(obj => {
              const dict = obj.morphTargetDictionary;
              const idx = dict ? dict[real] : undefined;
              if (idx != null && obj.morphTargetInfluences) {
                obj.morphTargetInfluences[idx] = value;
              }
            });
          };

          this.setBoneRotation = (key, euler) => {
            const bone = this.boneMap[key];
            if (!bone) return;
            bone.rotation.set(euler.x || 0, euler.y || 0, euler.z || 0);
          };
        },
        tick: function (time, timeDelta) {
          if (this.mixer) this.mixer.update(timeDelta / 1000);
        },
        remove: function () {
          this.el.removeEventListener('model-loaded', this.onModelLoaded);
          this.mixer = null;
          this.actions = {};
        }
      });

      // Agora usamos os eventos do marcador para ativar/desativar comportamentos
      marker.addEventListener('markerFound', () => {
        console.log('⭐ Marcador detectado!');
        document.getElementById('marker').textContent = '✓ DETECTADO';
        document.getElementById('marker').className = 'ok';
        document.getElementById('detectado').classList.add('ativo');
        document.getElementById('msg').textContent = '✓ Modelo Carregado!';

        // Seleciona o modelo e inicia rotação.
        // A fala NÃO será iniciada automaticamente — o usuário deverá pressionar o botão após o retângulo desaparecer.
        const modelEl = document.getElementById('modelo-personagem');
        if (modelEl) {
          // Se o componente de rotação já estiver inicializado, usa seu método start()
          const rotComp = modelEl.components['rotating-when-visible'];
          if (rotComp && rotComp.start) {
            rotComp.start();
          } else {
            // Garante que o componente exista (caso não tenha sido inicializado ainda)
            modelEl.setAttribute('rotating-when-visible', '');
            // Tenta novamente após pequeno delay para garantir inicialização
            setTimeout(() => {
              const r = modelEl.components['rotating-when-visible'];
              if (r && r.start) r.start();
            }, 50);
          }
        }

        // Inicia estado Idle (se houver) ao detectar marcador
        if (modelEl) {
          const motion = modelEl.components['character-motion'];
          if (motion && motion.playMotion) motion.playMotion('idle', { loop: true, fade: 0.2 });
        }

        // Após 2 segundos removemos o retângulo verde da tela e mostramos o botão "Ouvir fala"
        // Isso evita sobreposição visual e segue o pedido do usuário: permitir que o usuário pressione Play
        setTimeout(() => {
          const detectEl = document.getElementById('detectado');
          if (detectEl) detectEl.classList.remove('ativo');
          const btn = document.getElementById('btn-play-fala');
          if (btn) btn.style.display = 'block';
        }, 2000);
      });

      marker.addEventListener('markerLost', () => {
        console.log('Marcador perdido');
        document.getElementById('marker').textContent = '⟳ Procurando';
        document.getElementById('marker').className = 'erro';
        document.getElementById('detectado').classList.remove('ativo');
        document.getElementById('msg').textContent = 'Procurando marcador...';

        // Para rotação e fala quando marcador é perdido
        const modelEl = document.getElementById('modelo-personagem');
        if (modelEl) {
          const rotComp = modelEl.components['rotating-when-visible'];
          if (rotComp && rotComp.stop) rotComp.stop();

          const speechComp = modelEl.components['character-speech'];
          if (speechComp && speechComp.stopSpeech) speechComp.stopSpeech();
          const motion = modelEl.components['character-motion'];
          if (motion && motion.stopAll) motion.stopAll();
        }
        // Esconde o botão de play quando o marcador some
        const btn = document.getElementById('btn-play-fala');
        if (btn) btn.style.display = 'none';
      });

      // --- Fallback UI: botão para tocar fala manualmente (se autoplay bloqueado) ---
      const btnPlayFala = document.getElementById('btn-play-fala');
      if (btnPlayFala) {
        btnPlayFala.addEventListener('click', () => {
          // Tenta acionar a fala no modelo (se o componente estiver disponível)
          const modelEl = document.getElementById('modelo-personagem');
          if (modelEl) {
            const speechComp = modelEl.components['character-speech'];
            if (speechComp && speechComp.playSpeech) {
              speechComp.playSpeech();
              // Oculta o botão após o clique
              btnPlayFala.style.display = 'none';
            } else {
              // Caso o componente ainda não esteja pronto, inicializa e tenta novamente
              modelEl.setAttribute('character-speech', '');
              setTimeout(() => {
                const s = modelEl.components['character-speech'];
                if (s && s.playSpeech) s.playSpeech();
                btnPlayFala.style.display = 'none';
              }, 100);
            }
          } else {
            // Se não há modelo, tenta tocar o elemento <audio> diretamente como fallback
            const audio = document.getElementById('fala1');
            if (audio) {
              audio.play().catch(err => console.warn('Erro ao tocar áudio diretamente:', err));
              btnPlayFala.style.display = 'none';
            }
          }
        });
      }

      // --- Upload de GLB e Áudio (opcional) ---
      (function setupUploads(){
        const glbInput = document.getElementById('glbInput');
        const audioInput = document.getElementById('audioInput');
        const modelEl = document.getElementById('modelo-personagem');
        const audioEl = document.getElementById('fala1');
        const msgEl = document.getElementById('msg');
        let currentModelBlobUrl = null;
        let currentAudioBlobUrl = null;

        if (glbInput && modelEl) {
          glbInput.addEventListener('change', (ev) => {
            const file = ev.target.files && ev.target.files[0];
            if (!file) return;
            const name = (file.name || '').toLowerCase();
            if (!name.endsWith('.glb')) {
              console.warn('Arquivo selecionado não é .glb');
              if (msgEl) msgEl.textContent = 'Arquivo inválido. Selecione um .glb';
              return;
            }
            try {
              // Revoga URL anterior, se houver
              if (currentModelBlobUrl) URL.revokeObjectURL(currentModelBlobUrl);
              currentModelBlobUrl = URL.createObjectURL(file);
              // Atualiza fonte do modelo diretamente com a Blob URL
              modelEl.setAttribute('src', currentModelBlobUrl);
              if (msgEl) msgEl.textContent = '✓ Modelo (.glb) carregado';
            } catch (e) {
              console.warn('Falha ao carregar GLB:', e);
              if (msgEl) msgEl.textContent = 'Falha ao carregar GLB';
            }
          });
        }

        if (audioInput && audioEl) {
          audioInput.addEventListener('change', (ev) => {
            const file = ev.target.files && ev.target.files[0];
            if (!file) return;
            try {
              if (currentAudioBlobUrl) URL.revokeObjectURL(currentAudioBlobUrl);
              currentAudioBlobUrl = URL.createObjectURL(file);
              audioEl.pause();
              audioEl.src = currentAudioBlobUrl;
              audioEl.load();
              if (msgEl) msgEl.textContent = '✓ Áudio carregado (use "Ouvir fala")';
              // Mostra botão para o usuário iniciar a reprodução quando quiser
              const btn = document.getElementById('btn-play-fala');
              if (btn) btn.style.display = 'block';
            } catch (e) {
              console.warn('Falha ao carregar áudio:', e);
              if (msgEl) msgEl.textContent = 'Falha ao carregar áudio';
            }
          });
        }
      })();

      // --- Menu de 3 pontos: toggle do painel ---
      (function setupMenu(){
        const btn = document.getElementById('menu-btn');
        const panel = document.getElementById('menu-panel');
        if (!btn || !panel) return;
        btn.addEventListener('click', () => {
          panel.style.display = panel.style.display === 'none' || panel.style.display === '' ? 'block' : 'none';
        });
      })();

      // --- Controles de transformação ---
      (function setupTransformControls(){
        const modelEl = document.getElementById('modelo-personagem');
        if (!modelEl) return;
        const scaleSlider = document.getElementById('scaleSlider');
        const posX = document.getElementById('posX');
        const posY = document.getElementById('posY');
        const posZ = document.getElementById('posZ');
        const rotY = document.getElementById('rotY');

        const setScale = (s) => { modelEl.setAttribute('scale', `${s} ${s} ${s}`); };
        const setPos = () => { modelEl.setAttribute('position', `${parseFloat(posX.value)||0} ${parseFloat(posY.value)||0} ${parseFloat(posZ.value)||0}`); };
        const setRotY = (y) => {
          const rot = modelEl.getAttribute('rotation') || {x:0,y:0,z:0};
          rot.y = parseFloat(y)||0; modelEl.setAttribute('rotation', rot);
        };

        if (scaleSlider) scaleSlider.addEventListener('input', (e)=> setScale(e.target.value));
        if (posX) posX.addEventListener('change', setPos);
        if (posY) posY.addEventListener('change', setPos);
        if (posZ) posZ.addEventListener('change', setPos);
        if (rotY) rotY.addEventListener('input', (e)=> setRotY(e.target.value));
      })();

      // --- Botões de Motion ---
      (function setupMotionButtons(){
        const modelEl = document.getElementById('modelo-personagem');
        if (!modelEl) return;
        const btnIdle = document.getElementById('btn-idle');
        const btnWave = document.getElementById('btn-wave');
        const btnStop = document.getElementById('btn-stop-motion');
        const motion = modelEl.components['character-motion'];
        if (btnIdle && motion && motion.playMotion) btnIdle.addEventListener('click', ()=> motion.playMotion('idle', { loop: true, fade: 0.2 }));
        if (btnWave && motion && motion.playMotion) btnWave.addEventListener('click', ()=> motion.playMotion('wave', { loop: false, fade: 0.2 }));
        if (btnStop && motion && motion.stopAll) btnStop.addEventListener('click', ()=> motion.stopAll());
      })();

      // --- Aplicar mapeamento de clips/bones/morphs ---
      (function setupMapping(){
        const modelEl = document.getElementById('modelo-personagem');
        const motion = modelEl ? modelEl.components['character-motion'] : null;
        const btnApply = document.getElementById('btn-apply-mapping');
        if (!motion || !btnApply) return;
        btnApply.addEventListener('click', () => {
          const clips = {
            idle: (document.getElementById('mapClipIdle').value || 'Idle').trim(),
            wave: (document.getElementById('mapClipWave').value || 'Wave').trim(),
            talk: (document.getElementById('mapClipTalk').value || 'Talk').trim()
          };
          const bones = {
            jaw: (document.getElementById('mapBoneJaw').value || 'Jaw').trim(),
            handR: (document.getElementById('mapBoneHandR').value || 'RightHand').trim()
          };
          const morphs = {
            mouthOpen: (document.getElementById('mapMorphMouthOpen').value || 'MouthOpen').trim()
          };
          motion.setConfig({ clips, bones, morphs });
          // Reconstruir mapas após novo config (se o modelo já estiver carregado)
          if (motion._buildMaps) motion._buildMaps();
          const msgEl = document.getElementById('msg');
          if (msgEl) msgEl.textContent = '✓ Mapeamento aplicado';
        });
      })();
    </script>
  </body>
</html>
